-for f in f_slices:
-    Ls = len(f)
-    ft = fft(f)
-
-    if temp0 is None:
-        temp0 = torch.empty(maxLg, dtype=ft.dtype)
-
-    if nn > Ls:
-        ft = torch.concatenate((ft, torch.zeros(nn-Ls, dtype=ft.dtype)))
-
-    c = [] # Initialization of the result
-
-    for mii,_,gi1,gi2,win_range,Lg,col in loopparams:
-        temp = temp0[:col*mii]
-
-        t1 = temp[:(Lg+1)//2]
-        t1[:] = gi1  # if mii is odd, this is of length mii-mii//2
-        t2 = temp[-(Lg//2):]
-        t2[:] = gi2  # if mii is odd, this is of length mii//2
-
-        ftw = ft[win_range]
-        t2 *= ftw[:Lg//2]
-        t1 *= ftw[Lg//2:]
-
-        temp[(Lg+1)//2:-(Lg//2)] = 0  # clear gap (if any)
-
-        if col > 1:
-            temp = torch.sum(temp.reshape((mii,-1)), axis=1)
-        else:
-            temp = temp.clone()
-
-        c.append(temp)
-
-    y = list(mmap(ifft,c))
-    yield y

+ragged_giis = [torch.nn.functional.pad(torch.unsqueeze(gii, dim=0), (0, maxLg-gii.shape[0])) for gii in g[sl]]
+giis = torch.conj(torch.cat(ragged_giis))
+
+f = torch.cat([torch.unsqueeze(f, dim=0) for f in f_slices])
+ft = fft(f)
+
+Ls = f.shape[-1]
+
+c = torch.empty(f.shape[0], len(loopparams), maxLg, dtype=ft.dtype, device=get_torch_device())
+
+for j, (mii,win_range,Lg,col) in enumerate(loopparams):
+    t = ft[:, win_range]*torch.fft.fftshift(torch.conj(giis[j, :Lg]))
+
+    c[:, j, :(Lg+1)//2] = t[:, Lg//2:]  # if mii is odd, this is of length mii-mii//2
+    c[:, j, -(Lg//2):] = t[:, :Lg//2]  # if mii is odd, this is of length mii//2
+    c[:, j, (Lg+1)//2:-(Lg//2)] = 0  # clear gap (if any)
+
+y = ifft(c)
+return y
