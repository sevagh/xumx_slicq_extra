\documentclass[report.tex]{subfiles}
\begin{document}

\todo[inline]{section introductions, improve wording of results, cleanup}

\section{Discussion and conclusion}

\subsection{Discussion of results}
\label{sec:discussion}

This section contains the discussion of the results shown in section \ref{sec:experiment}.

\subsubsection{GPU acceleration benchmarks}

Table \ref{table:nsgttorchresultsragged} from section \ref{sec:gpuexperiments} contained the benchmark results for the PyTorch implementation of the ragged sliCQT compared to the original library.

The execution time of the transform improved with PyTorch in every case. Even though the sliCQT computed on the GPU is not faster than the CPU for the tested parameters, having the transform on the GPU allows us to use the sliCQT inside a PyTorch neural network. The original library has a multithreaded option which performs worse than the default single-threaded behavior, but the PyTorch CPU performance beats both.

Section \ref{sec:gpuexperiments} also described the benchmarking of the GPU-accelerated BSS metrics library developed for xumx-sliCQ.\footnote{\url{https://github.com/sevagh/sigsep-mus-eval}} The results showed that a \textasciitilde2-2.5x time savings can be expected over the CPU, which represent a significant reduction in the time taken to compute BSS evaluations of music demixing systems, that can be useful for various evaluation campaigns like SiSEC \parencite{sisec2018} or MDX \parencite{mdx21}.

\subsubsection{Best sliCQT parameters}

The sliCQT MPI oracle results achieved a median SDR of 7.42 dB, beating the 6.23 dB achieved by the STFT with UMX settings. This indicates that a music demixing system that uses the sliCQT with these parameters has the potential to surpass STFT-based performance.

Keep in mind that to translate this theoretical boost to a real advantage in the final model, a neural network architecture must be chosen that can produce a good estimate of the target magnitude sliCQT. Note the sharper clarity of musical events in both time and frequency in the sliCQT spectrogram in Figure \ref{fig:bipolarslicqs}(a) compared to the STFT spectrogram in Figure \ref{fig:bipolarslicqs}(b). We hope that this added information gives the neural network an advantage when learning how to demix music from the sliCQT representation over the STFT.

\subsubsection{xumx-sliCQ neural network}
\label{sec:netdiscuss}

First, , the zero-padded matrix form of the sliCQ-Wiener-EM was significantly faster than looping over the ragged form, with a negligible drop in SDR. For this reason, the zero-padded sliCQ-Wiener-EM is the chosen implementation of sliCQT-based Wiener-EM in the final model, and the ragged sliCQ-Wiener-EM was discarded for being too computationally slow.

In xumx-sliCQ, a parameter called \Verb#slicq_wiener#\footnote{\url{https://github.com/sevagh/xumx-sliCQ/blob/v2021/xumx_slicq/model.py\#L380}} was added to switch between the zero-padded sliCQ-Wiener-EM and STFT-Wiener-EM strategies. The default chosen is STFT-Wiener-EM for the best tradeoff of music demixing performance and execution speed.

For both STFT and sliCQT-based Wiener-EM, two iterations were worse than one iteration. The computation time of the inference step will be shown in section \ref{sec:inferenceperf} to discuss the tradeoff between the STFT and sliCQT Wiener-EM.


Table \ref{table:bsseval} from section \ref{sec:demixresults} showed that xumx-sliCQ performed worse than UMX and X-UMX, with both configurations of Wiener-EM.

Section \ref{sec:inferenceperf} described the running time analysis of the inference of xumx-sliCQ. The STFT-WEM configuration of xumx-sliCQ runs \textasciitilde2x slower than UMX, and the sliCQT-WEM configuration runs \textasciitilde4x slower than UMX. We note that the sliCQT-WEM configuration only adds \textasciitilde0.1 dB to the median SDR score compared to the STFT-WEM variant, which is a poor tradeoff considering it doubles the running time. xumx-sliCQ's advantage is that it is \textasciitilde4.9x smaller on disk than UMX.

\subsection{Conclusion}
\label{sec:conclusion}

\todo[inline]{unfuck these}

The creation of xumx-sliCQ led to several contributions to the current Python ecosystem for music demixing. First, Second, the PyTorch implementation of the NSGT and sliCQT allow these transforms to be used in GPU machine learning and deep learning networks.

The proposed model, xumx-sliCQ, failed to beat the music demixing performance of Open-Unmix (UMX) and CrossNet-Open-Unmix (X-UMX), but it demonstrates a working prototype of sliCQT-based music demixing.

\subsection{Summary and outlook}

The STFT has known limitations that arise from its fixed time-frequency resolution. Methods of spectral music demixing that use the STFT have addressed this limitation by using multiple STFTs or by using different time-frequency transforms like the CQT. In many STFT-based models for music demixing, the phase is discarded for simplicity and the network operates on the magnitude STFT.

The advantage of the sliCQT is that it can provide a method for computing a time-frequency transform with the familiar complex-valued Fourier coefficients and a perfect inverse operation for arbitrary frequency scales. The signal or application under study can dictate the frequency scale used. The goal of using the sliCQT in a music demixing application was to see if the improved time-frequency resolution, and an appropriately-chosen frequency scale, could improve the performance of STFT-based models.

In this thesis, two near-SOTA STFT-based models, Open-Unmix (UMX) and its closely-related variant CrossNet-Open-Unmix (X-UMX), were adapted to use the sliCQT and create a new model for music demixing called xumx-sliCQ. xumx-sliCQ did not surpass UMX and X-UMX, but we believe it represents a promising start to sliCQT-based music demixing techniques.

Looking towards the future, a direction to explore is using the improved variant of the NSGT/sliCQT \parencite{variableq1}, which is the CQ-NSGT implementation used in the cqt function of the MATLAB Wavelet Toolbox.\footnote{\url{https://www.mathworks.com/help/wavelet/ref/cqt.html}} A matrix form is proposed which uses rasterization, or interpolation, of the low-frequency bins to match the larger size of time coefficients of the high-frequency regions. This would create a single matrix for the sliCQT, eliminating the challenges of working with the ragged shape of the transform in this paper. \textcite{variableq1} also proposed to improve the phase of the transform, which may affect the quality of the time-domain waveform estimate from the mix-phase inversion.

\end{document}
